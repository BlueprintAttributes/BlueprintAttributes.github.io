{"/docs/attribute-sets":{"title":"Attribute Sets","data":{"attribute-sets#Attribute Sets":"Registering the Attribute Set with the ASC\nInitialization\nBuilt in Clamping\nInteractions with Gameplay Effects\nHelper Methods\nReplication"}},"/docs/attribute-sets/built-in-clamping":{"title":"Built-in Clamping","data":{"":"Clamping of Attribute, to ensure that their values are always within the limits that you set for them, is a common pattern. That's why Blueprint Attributes plugin come with some pre-defined and built-in clamping behavior that you can opt-in.You can perform Attributes clamping with one of three methods, two of which are the built-in clamping features coming with the plugin.\nwith DataTable - To initialize the Attributes, and using the MinValue and MaxValue columns. The Attribute Set Blueprint Base class is able to handle those Min/Max column values, and execute a built-in clamping behavior.\nwith Gameplay Clamped Attribute Data properties - A customizable clamping using a special Gameplay Clamped Attribute Data property (a child of FGameplayAttributeData) with float or Attribute-based clamping.\nManual Clamping - You'd implement the clamping behavior yourself, with your own rules with the BP exposed method / events of Attribute Sets (PreAttributeChange(), PreAttributeBaseChange() or PostGameplayEffectExecute())\nUGBAAttributeSetBlueprintBase::PostGameplayEffectExecute() is the method responsible of clamping, and the order for those is the following:\nManual Clamping (if done in PostGameplayEffectExecute BP Event)\nClamping via Clamped Properties (if the Attribute is implemented as a FGBAGameplayClampedAttributeData).\nClamping via DataTables Min and Max value columns (if the Set was initialized with a DataTable, and if MinValue < MaxValue).\nTest Setup To better illustrate the clamping behavior in-game, we'll use Gameplay Effects with Infinite duration to setup a regen and degen mechanic for the Health Attribute.\nYou could also use Gameplay Abilities activated on Input, to apply an Instant Gameplay Effect to either damage or heal the Character (by adding or removing a set of amount of Hit Points from the Health Attribute).\nThis demonstration setup can be found in the Content Examples project in the 02_Builtin_Clamping map.Also, most of the assets specific to this example are prefixed with GE_Clamping_ to easily find them in the Editor with Ctrl+P.\nFor these instructions, I'm using an AttributeSet made just for this clamping demonstration, with a single Health Attribute variable.GBA_Clamping_Example_HealthSet\nAnd two Gameplay Effects, one to continuously add to the Health Attribute, one to continuously substract from the Health Attribute.GE_Clamping_HealthRegen\nGE_Clamping_HealthDegen\nBoth are Infinite Gameplay Effects, with a Period duration of 0.1, and either adds or remove 10 from the Health Attribute every 100ms.GE_Clamping_HealthRegen is configured to only be active if the Owner Character doesn't have GameplayEffect.Clamping.Degen Gameplay Tag, which is added by GE_Clamping_HealthDegen whenever it's applied.Next, we need to ensure the Regen Gameplay Effect is applied. Since it's an Infinite Effect, it'll be active indefinitely (or until explicitly removed).You can simply apply the effect programmatically on Begin Play (or Possesed) event, or using the list of Gameplay Effects to apply your GAS bakend could provide to you (GAS Companion's ASC Granted Effects, or Lyra's Ability Sets and Granted Gameplay Effects)Without any clamping applied, the Health Attribute value will go up indefinitely.And similarly go down if we apply the Degen effect (which is done in the Content Examples project by stepping onto the Button Pad Blueprint).","with-datatable#With DataTable":"This is the simplest and quickest way to get clamping done for Gameplay Attributes.This implies you're using a DataTable to initiliaze your Attribute values (eg. Data Tables section).\nIf we build upon our previous Attribute Set example, with a single Health Attribute, we can tweak the DataTable used for initialization and set the Min and Max value columns to arbitrary values. In the following example, we'll init the value to 0, but configure the clamping to ensure the value will be between 10 and 100.If we launch the game in PIE, we can see the value for the Health Attribute initialized to 10 (started at 0, then clamping took place and set it to 10)To test lower and higher bound limits we configured for the clamping, we can use the Regen / Degen effect described in the Test Setup section.","with-gameplay-clamped-attribute-data-properties#With Gameplay Clamped Attribute Data properties":"Add a new Attribute for your set, but this time using a FGBAGameplayClampedAttributeData. You can quickly do so by clicking on the \"Add Attribute\" button in the Blueprint Editor Toolbar, and choosing the appropriate type.\nOnce again, you can find the implementation described here as part of the Content Examples project in the 02_Builtin_Clamping map.\nThis time, we are going to implement an Endurance Attribute (a classic! sometimes also called Stamina) that could act as a resource cost for a given set of actions. In this simple example, we'll reuse the Regen mechanic and temporarily increase the higher clamp limit when we step onto a Button Pad.If you then compile the Blueprint and select the newly added variable, you'll see in the Details panel a slightly different display.FGBAGameplayClampedAttributeData is a child struct of FGameplayAttributeData, it contains the usual Base Value, along with two new FGBAClampDefinition properties: a MinValue and a MaxValue.The Clamp definition for both of these provides a Clamp Type behavior:\nFloat Based (default): Uses a simple, static float for the clamping.\nAttribute Based: Performs a clamping based upon another attribute.\nNone: Clamping is disabled for this definition.\nWe need another Attribute to demonstrate the Attribute Based clamping type for our Endurance attribute called MaxEndurance. Let's quickly create the new attribute.You can then give it an arbitrary value (and / or use an initialization DataTable to set its value):We can then go back to the clamped definitions of Endurance, by selecting the variable or using the Class Defaults view, and adjust the clamping definition for MaxValue to be based on the MaxEndurance attribute.\nWe also changed the initial Base Value to be at 100 to make it start from the higher limit.\nTake note that only the Attributes belonging to the same Attribute Set are intentionally selectable. This deliberate design choice serves to prevent interdependence between different Attribute Set classes and to maintain the principle of encapsulation.\nTest Setup Let's quickly create a few Gameplay Effects to play around our new Endurance attribute value. We'll need:\nA regen Gameplay Effect to continuously add a certain amount of Endurance point.\nA Gameplay Effect to arbitrarely change the value of MaxEndurance attribute (imagine equipping an item that increase the total amount of Endurance available) which is going to indirectly affect the maximum value for the Endurance attribute.\nThe few following Blueprints are set to \"Show Only Modified Properties\"\nGE_Clamping_EnduranceRegen\nThis is an infinite Gameplay Effect\nGE_Clamping_MaxEnduranceBuff\nThis is a duration Gameplay Effect, meaning it will only last for 2 second, and increase MaxEndurance by 100%.\nDon't forget to apply GE_Clamping_EnduranceRegen just like we did for the HealthRegen as one of the startup effects to apply.\nTime to PIE test. Here we used the AbilitySystem.DebugAttribute Endurance MaxEndurance command once to display their value as an additional overlay.\nBy stepping onto the Pad Button, we apply the Gameplay Effect buff to increase temporarily our MaxAttribute value for 2s (or removed when we step out of the Pad).","manual-clamping#Manual Clamping":"Manual clamping resort to your own implementation using some of the Blueprint exposed methods of UAttributeSet you can implement or override.","using-preattributechange-and-preattributebasechange#Using PreAttributeChange() and PreAttributeBaseChange()":"Click on the \"Override\" dropdown in the functions tab to override the function PreAttributeBaseChange in Blueprint.\nSame for PreAttributeChange function.\nAnd we'll implement both exactly the same way (you could create an helper function in your Blueprint to handle the clamping, and call that method from both of these places).\nSwitch on Gameplay Attribute K2 Node is a custom node implemented by the plugin (originally implemented in GAS Companion, and ported over here in Blueprint Attributes). This is one of the few features both plugins share and each implement their own identical version of the node.\nIn Value float represents the initial Base or Current value (Base for PreAttributeBaseChange method, Current - sometimes also called Final - Value for the PreAttributeChange).Both of these methods must return an Out Value float which is going to be new clamped value for the Attributes we care about (here we only deal with the Shield Attribute). For any other attributes that doesn't need clamping, we simply return the initial In Value.","using-postgameplayeffectexecute#Using PostGameplayEffectExecute()":"When the AttributeSet Blueprint is first created, the event is implemented by default but disabled.\nIf the event the node is missing or you previously deleted it, you can click on the \"Override\" dropdown again in the functions tab to implement the PostGameplayEffectExecute event in Blueprint.\nAs for the implementation, you can implement the clamping using ClampAttributeValue helper of UGBAAttributeSetBlueprintBase (displayed Attribute Set Blueprint Base) parent class."}},"/docs/attribute-sets/helper-methods":{"title":"Helper Methods","data":{"":"Additionnaly, UGBAAttributeSetBlueprintBase defines a few custom helper intended to be used when implementing the AttributeSet events / methods described earlier.","getattributevalue#GetAttributeValue()":"Method descriptionReturns the current (as opposed to base) value of an Attribute.\nThis method acts as a simple proxy towards UAbilitySystemBlueprintLibrary::GetFloatAttributeFromAbilitySystemComponent() with the ASC returned from GetOwningAbilitySystemComponent()\nParameters\nName\tType\tDescription\tAttribute\tFGameplayAttribute\tThe Gameplay Attribute we want to get the current value\tbSuccessfullyFoundAttribute\tbool\tReturn value indicating whether the value was retrieved successfully (false if owning ASC is invalid or if the AttributeSet the input Attribute belongs to is not granted)","getattributebasevalue#GetAttributeBaseValue()":"Method descriptionReturns the base (as opposed to current) value of an Attribute.\nThis method acts as a simple proxy towards UAbilitySystemBlueprintLibrary::GetFloatAttributeBaseFromAbilitySystemComponent() with the ASC returned from GetOwningAbilitySystemComponent()\nParameters\nName\tType\tDescription\tAttribute\tFGameplayAttribute\tThe Gameplay Attribute we want to get the base value\tbSuccessfullyFoundAttribute\tbool\tReturn value indicating whether the value was retrieved successfully (false if owning ASC is invalid or if the AttributeSet the input Attribute belongs to is not granted)","setattributevalue#SetAttributeValue()":"Method descriptionSets the base (as opposed to current) value of an Attribute.\nYou'll get a warning if owning ASC is null, and an ensure error if the AttributeSet the input Attribute belongs to is not granted.\nParameters\nName\tType\tDescription\tAttribute\tFGameplayAttribute\tThe Gameplay Attribute we want to set the base value\tNewValue\tfloat\tFloat value to set","clampattributevalue#ClampAttributeValue()":"Method descriptionClamps the Attribute from MinValue to MaxValue\nYou'll get a warning if owning ASC is null, and an ensure error if the AttributeSet the input Attribute belongs to is not granted.\nParameters\nName\tType\tDescription\tAttribute\tFGameplayAttribute\tGameplay Attribute to clamp the value\tMinValue\tfloat\tThe lower bound float to clamp the value within\tMaxValue\tfloat\tThe higher bound float to clamp the value within","getowningactor#GetOwningActor()":"Method descriptionGets information about owning actor.Return valueAActor* usually representing the OwningActor of the ASC.","getowningabilitysystemcomponent#GetOwningAbilitySystemComponent()":"Method descriptionReturns the Ability System Component of the Owning Actor.Return valueUAbilitySystemComponent* of the Owning Actor.","getactorinfo#GetActorInfo()":"Method descriptionReturns the Owner's Ability System Component cached data about the owning actor that abilities will need to frequently access (movement component, mesh component, anim instance, etc)Return valueFGameplayAbilityActorInfo representing the ActorInfo of the Owning Actor.\nYou'll get an Error if we were unable to get back the ActorInfo cached pointer, and result will be a default FGameplayAbilityActorInfo with none of its member properly populated.","handlerepnotifyforgameplayattributedata#HandleRepNotifyForGameplayAttributeData()":"This method is meant to be used in the context of a RepNotify Blueprint implementation for an Attribute.\nMethod descriptionTo be called from Blueprint rep notifies for a given Gameplay Attribute Data member variable.Meant to provide the same prediction capabilities of GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Attribute, OldAttribute) macro that is usually called from within a C++ AttributeSet rep notify handler.Parameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttributeData&\tAttribute Name - must match the rep notify attribute name","handlerepnotifyforgameplayclampedattributedata#HandleRepNotifyForGameplayClampedAttributeData()":"This method is meant to be used in the context of a RepNotify Blueprint implementation for an Attribute.\nThis is exactly the same as method as HandleRepNotifyForGameplayAttributeData() above but taking a FGBAGameplayClampedAttributeData input parameter instead.\nMethod descriptionTo be called from Blueprint rep notifies for a given Gameplay Attribute Data member variable.Meant to provide the same prediction capabilities of GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Attribute, OldAttribute) macro that is usually called from within a C++ AttributeSet rep notify handler.Parameters\nName\tType\tDescription\tInAttribute\tconst FGBAGameplayClampedAttributeData&\tAttribute Name - must match the rep notify attribute name"}},"/docs/attribute-sets/initialization":{"title":"Initialization","data":{"":"In this section, we'll talk about the various ways we have to initialize the Attribute values (the Base Value).","initializing-attributes#Initializing Attributes":"This is a good time to talk about a Blueprint Attributes plugin specific feature. If you select the Gameplay Attribute property in the Blueprint Editor, or click on the \"Class Defaults\" button in the toolbar, you'll be able to change the default Attribute value directly from within the Details Panel.Set it to an arbitrary value, for example 100.\nThis is normally not an exposed value, and not editable in the Details panel, but an Editor Details customization of Blueprint Attributes plugin is taking care of exposing that to Blueprints.\nThis is the equivalent in C++ of setting a Gameplay Attribute default value via its constructor in an AttributeSet header:\nUPROPERTY(BlueprintReadOnly, Category = \"Attributes\", ReplicatedUsing = OnRep_Health)\nFGameplayAttributeData Health = 0.0f;\nIf we now launch the game in PIE and use the Gameplay Debugger commands, we should see the Attribute with its new default value:","data-tables#Data Tables":"Another popular way to initialize attributes beyond their default value, and further specialize Gameplay Attributes value based on the Actor (and ASC) it belongs, is through the use of Data Table.Both the InitStats() method of the ASC and its Default Starting Data property (more infos and options in Register Attribute Sets with the ASC) accepts an additional Data Table and a Gameplay Ability System row type called AttributeMetaData.Example using InitStats() on Begin Play or Possessed Events","creating-the-data-table#Creating the Data Table":"","manually#Manually":"Hint: The next section explains how to do this automatically 😉\nYou can create AttributeMetaData Data Tables the usual way, by right-clicking in the Content Browser, and clicking on Miscellaneous > Data Table (or importing from an external .csv file).In the \"Pick Row Structure\" dialog that appears, choose AttributeMetaData for the row type.You have the option to add extra rows to support Attribute Sets with multiple Gameplay Attributes. In the file shown below, the \"Health\" Gameplay Attribute within GBA_Health_Set Blueprint will initialize with a value of 1000.The syntax for the row name is AttributeClassName.AttributeName (without the \"U\" prefix for C++ defined Attribute Set, and without the \"_C\" suffix for Blueprint defined Attribute Set).","automatically-with-create-datatable-toolbar-button#Automatically with Create DataTable Toolbar Button":"The Blueprint Attributes Editor Toolbar provides an additional \"Create DataTable\" button to quickly create an initialization AttributeMetaData Data Table, based on the defined Gameplay Attributes in the Blueprint Editor.It'll generate additional rows for each defined Attributes, with their Base Value set accordingly.If you click on the \"Create DataTable\" button, you'll get the following window:\nIf you click on \"Save\" next, a new DataTable asset with the appropriate row type and content generated based on your defined attributes will be created.\nThe path for the DataTable is by default next to the Attribute Set Blueprint it originates from, but you can tweak this with the left panel and Tree View.\nThe name for the DataTable is by default DT_{AttributeBlueprintName} (for instance for a Blueprint GBA_Health_Set, the default name for the DataTable will be DT_GBA_Health_Set). You can change the name of the DataTable asset in the Name input field.\nHere is an example for a Blueprint AttributeSet with slightly more Gameplay Attributes, and their BaseValue slightly modified:\nAnd here is the resulting DataTable:"}},"/docs/attribute-sets/interactions-with-gameplay-effects":{"title":"Interactions with Gameplay Effects","data":{"":"There are several functions that an Attribute Set can override to deal with the way an Attribute responds when a Gameplay Effect attempts to modify it.Most of this API is exposed to Blueprints (PostGameplayEffectExecute, Pre/PostAttributeChange, ...).","preattributechange--preattributebasechange#PreAttributeChange / PreAttributeBaseChange":"They serve a similar purpose and share the same method signature.One is invoked when the Current Value is modified, the other when the Base Value is changed.\nTo learn more about BaseValue vs CurrentValue, check out 4.3.2 part of the most excellent GASDocumentation on GitHub.\nPermanent changes to the BaseValue come from Instant GameplayEffects whereas Duration and Infinite GameplayEffects change the CurrentValue. Periodic GameplayEffects are treated like instant GameplayEffects and change the BaseValue.","preattributechange#PreAttributeChange":"Method descriptionCalled just before any modification happens to an attribute. This is lower level than PreAttributeModify/PostAttribute modify.There is no additional context provided here since anything can trigger this. Executed effects, duration based effects, effects being removed, immunity being applied, stacking rules changing, etc.This function is meant to enforce things like \"Health = Clamp(Health, 0, MaxHealth)\" and NOT things like \"trigger this extra thing if damage is applied, etc\".OutValue is a mutable reference so you are able to clamp the newly applied value as well\nNote When overriding in BP, OutValue is the return value of the overriden BP function, make sure to pass in the new value. Typical implementation should simply return the input value parameter (or a clamped value based on InValue).\nParameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose current (or final) value is about to change\tInValue\tfloat\tOriginal value for the Gameplay Attribute\tOutValue\tfloat\tReturn value of the function which represents the new current value for the Gameplay Attribute","preattributebasechange#PreAttributeBaseChange":"Method descriptionThis is called just before any modification happens to an attribute's base value.This function should enforce clamping (presuming you wish to clamp the base value along with the final value in PreAttributeChange)This function should NOT invoke gameplay related events or callbacks. Do those in PreAttributeChange() which will be called prior to the\nfinal value of the attribute actually changing.Parameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose base value is about to change\tInValue\tfloat\tOriginal value for the Gameplay Attribute\tOutValue\tfloat\tReturn value of the function which represents the new base value for the Gameplay Attribute","postattributechange--postattributebasechange#PostAttributeChange / PostAttributeBaseChange":"Similar pattern as previous section about Pre-hooks, they share similar pattern and method signature.The only difference between the two is that PostAttributeBaseChange is const, whereas PostAttributeChange is not (making the latter an implementable Event - as opposed to a overriden BP function).","postattributechange#PostAttributeChange":"Method descriptionCalled just after any modification happens to an attribute.Parameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose value has been changed\tOldValue\tfloat\tOriginal value for the Gameplay Attribute, before PreAttributeChange event and actual modification happened\tNewValue\tfloat\tNew value for the Gameplay Attribute, after PreAttributeChange event and modification happened","postattributebasechange#PostAttributeBaseChange":"Method descriptionCalled just after any modification happens to an attribute's base value right and after aggregation (when an attribute aggregator exists).Parameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose base value has been changed\tOldValue\tfloat\tOriginal value for the Gameplay Attribute, before PreAttributeBaseChange event and actual modification happened\tNewValue\tfloat\tNew value for the Gameplay Attribute, after PreAttributeBaseChange event and modification","pregameplayeffectexecute#PreGameplayEffectExecute":"Method descriptionCalled just before modifying the value of an attribute. AttributeSet can make additional modifications here.Return true to continue, or false to throw out the modificationNote this is only called during an 'execute'. E.g., a modification to the 'base value' of an attribute.\nIt is not called during an application of a GameplayEffect, such as a 5 second +10 movement speed buff.This should apply 'gamewide' rules. Such as clamping Health to MaxHealth or granting +3 health for every point of strength, etc\nPreGameplayEffectExecute can return false to 'throw out' this modification.\nNote: Be extra careful when overriding this function in BP, make sure to return true, otherwise the Gameplay Effects won't apply anymore.Since the default behavior for the editor is to implement the method with return value set to false, this is something to be wary off.\nParameters\nName\tType\tDescription\tInAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose base value has been changed\tInData\tconst FGBAAttributeSetExecutionData&\tPayload with information extracted from FGameplayEffectModCallbackData, the Source / Target actor, Ability System Component, Controllers, Effect Context, Specs and Source Tags, Magnitude and Delta values, etc.\t\nReturn valueReturn true to continue, or false to throw out the modification.","postgameplayeffectexecute#PostGameplayEffectExecute":"Method descriptionCalled just after a GameplayEffect is executed to modify the base value of an attribute. No more changes can be made.Note this is only called during an 'execute'. E.g., a modification to the 'base value' of an attribute. It is not called during an application of a GameplayEffect, such as a 5 second +10 movement speed buff.This should apply 'gamewide' rules. Such as clamping Health to MaxHealth or granting +3 health for every point of strength, etcParameters\nName\tType\tDescription\tAttribute\tconst FGameplayAttribute&\tThe Gameplay Attribute whose value has been changed by a Gameplay Effect\tInData\tconst FGBAAttributeSetExecutionData&\tPayload with information extracted from FGameplayEffectModCallbackData, the Source / Target actor, Ability System Component, Controllers, Effect Context, Specs and Source Tags, Magnitude and Delta values, etc.","struct-fgbaattributesetexecutiondata#struct FGBAAttributeSetExecutionData":"Structure holding various information to deal with AttributeSet lifecycle events (such as Pre/PostGameplayEffectExecute), extracting info from FGameplayEffectModCallbackData.\nThis struct is used as an input parameter for some of the AttributeSet BP exposed event / methods that are using FGameplayEffectModCallbackData in native code (PreGameplayEffectExecute and PostGameplayEffectExecute)\nName\tType\tDescription\tSourceActor\tAActor*\tThe physical representation of the Source ASC (The ability system component of the instigator that started the whole chain)\tTargetActor\tAActor*\tThe physical representation of the owner (Avatar) for the target we intend to apply to\tSourceASC\tUAbilitySystemComponent*\tThe ability system component of the instigator that started the whole chain\tTargetASC\tUAbilitySystemComponent*\tThe ability system component we intend to apply to\tSourceController\tAPlayerController*\tPlayerController associated with the owning actor for the Source ASC (The ability system component of the instigator that started the whole chain)\tTargetController\tAPlayerController*\tPlayerController associated with the owning actor for the target we intend to apply to\tSourceObject\tUObject*\tThe object this effect was created from\tContext\tFGameplayEffectContextHandle\tThis tells us how we got here (who / what applied us)\tSourceTags\tFGameplayTagContainer\tCombination of spec and actor tags for the captured Source Tags on GameplayEffectSpec creation\tSpecAssetTags\tFGameplayTagContainer\tAll tags that apply to the gameplay effect spec\tMagnitudeValue\tfloat\tHolds the modifier magnitude value, if it is available (for scalable floats)\tDeltaValue\tfloat\tHolds the delta value between old and new, if it is available (for Additive Operations)\t\nUSTRUCT(BlueprintType)\nstruct BLUEPRINTATTRIBUTES_API FGBAAttributeSetExecutionData\n{\n\tGENERATED_BODY()\n\t/** The physical representation of the Source ASC (The ability system component of the instigator that started the whole chain) */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<AActor> SourceActor = nullptr;\n\t/** The physical representation of the owner (Avatar) for the target we intend to apply to  */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<AActor> TargetActor = nullptr;\n\t/** The ability system component of the instigator that started the whole chain */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<UAbilitySystemComponent> SourceASC = nullptr;\n\t/** The ability system component we intend to apply to */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<UAbilitySystemComponent> TargetASC = nullptr;\n\t/** PlayerController associated with the owning actor for the Source ASC (The ability system component of the instigator that started the whole chain) */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<APlayerController> SourceController = nullptr;\n\t/** PlayerController associated with the owning actor for the target we intend to apply to */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<APlayerController> TargetController = nullptr;\n\t/** The object this effect was created from. */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tTObjectPtr<UObject> SourceObject = nullptr;\n\t/** This tells us how we got here (who / what applied us) */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tFGameplayEffectContextHandle Context;\n\t/** Combination of spec and actor tags for the captured Source Tags on GameplayEffectSpec creation */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tFGameplayTagContainer SourceTags;\n\t/** All tags that apply to the gameplay effect spec */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tFGameplayTagContainer SpecAssetTags;\n\t/** Holds the modifier magnitude value, if it is available (for scalable floats) */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tfloat MagnitudeValue = 0.f;\n\t/** Holds the delta value between old and new, if it is available (for Additive Operations) */\n\tUPROPERTY(BlueprintReadOnly, Category = \"Blueprint Attributes\")\n\tfloat DeltaValue = 0.f;\n\t/** Default constructor */\n\tFGBAAttributeSetExecutionData() = default;\n\t/**\n\t * Fills out FGBAAttributeSetExecutionData structure based on provided FGameplayEffectModCallbackData data.\n\t *\n\t * @param InModCallbackData The gameplay effect mod callback data available in attribute sets' Pre/PostGameplayEffectExecute\n\t */\n\texplicit FGBAAttributeSetExecutionData(const FGameplayEffectModCallbackData& InModCallbackData);\n\t/** Returns a simple string representation for this structure */\n\tFString ToString(const FString& InSeparator = TEXT(\", \")) const;\n};"}},"/docs/attribute-sets/registering-the-attribute-set-with-the-asc":{"title":"Registering the Attribute Set with the ASC","data":{"":"Once you create an Attribute Set with one or more Gameplay Attributes, we need to register (or grant) it to the appropriate Ability System Component.\nYou can refer to Register Attribute Sets with the ASC for more options.\nHere, we'll use the InitStats() engine method, as part of the ASC API, to grant the Attribute Set on Begin Play.If we now test in-game and use the gameplay debugger, we can see the Attributes properly registered with our ASC and ready to use.","gameplay-debugger#Gameplay Debugger":"Hit Play and launch the game in PIE, and open up the console command by pressing the backtick key ` (normally located below the ESC key) on QWERTY keyboards or the ² on AZERTY keyboards.\nYou can customize this in Project Settings > Engine > Input > Console > Console Keys.\nThen type showdebug abilitysystem in the console to display the Gameplay Debugger for Gameplay Abilities. You should in the first \"Attributes\" page the Attribute(s) we defined earlier.You can also use the new AbilitySystem.DebugAttribute command.Type AbilitySystem.DebugAttribute Health to add a little overlay for a simple display of desired attributes (you can pass a list of Attributes to display with a space separated list of Attribute names).\nYou can pass a list of Attributes to the command with a space separated list of Attribute names.\nEnter the command again to hide the overlay if it is visible (toggle behavior)."}},"/docs/attribute-wizard":{"title":"Attribute Wizard","data":{"overview#Overview":"The Attribute Wizard and Scaffold module is a major feature of Blueprint Attributes. This document aims to go through its usage.It's goal is to ease the process of transitioning Attributes defined in Blueprints (for instance, when the prototyping phase is done for a new gameplay mechanic) to C++.","open-attribute-wizard-window#Open Attribute Wizard Window":"You can bring up the Wizard Window from within the Content Browser, or from within the Blueprint Attributes Editor window.From Content Browser, right click a Gameplay Blueprint AttributeSet asset and choose \"Preview Equivalent C++ Header\"\nFrom within a Blueprint AttributeSet asset editor, click on \"Generate Equivalent C++\" in the toolbar\nYou'll be granted with the following window:","required-module-dependencies#Required Module Dependencies":"The first thing to take care of is proper module dependencies for the target Module we are going to generate the C++ class into, and you'll likely only need to do it once (if you always generate in the same module).You can choose the target C++ module with the combo box located right to the Name field. The first value is always the primary Game module, but if you'd like to have the AttributeSet C++ class generated in one of your Runtime plugin (installed in Project's Plugins/ folder), you can pick one of its module here.\nIf your target module Build.cs file doesn't define required module dependencies, the Wizard will complain and tell which modules are missing. It is important to setup properly to ensure we don't get compilation errors later on.You should see a warning \"Required Module Dependencies\" right above the preview window, and a longer explanation below the preview.\nYou can click the \"Required Module Dependencies\" button to open the Build.cs file for the selected module using your configured code editor (in Editor Settings > General > Source Code).You'll then need to add each of the missing module dependency in either Public or Private module dependencies for the Build.cs file (depending on whether you generate the C++ header in a Public or Private folder, the Class Type Public or Private option)\nGBA_ContentExamples Runtime module is missing a few module dependencies, let's fix that.\nWe need to add the following modules:\nGameplayAbilities\nGameplayTags\nGameplayTasks\nBlueprintAttributes (because one of the Attributes is using a Clamped property - for FGBAGameplayClampedAttributeData)\nUpon saving the module Build.cs file, the Wizard window should update and eventually all the warning and error output should be gone.\nKeep in mind, the plugin only check if the Build.cs file matches each of the required module, meaning it only check if it contains \"GameplayAbilities\" for instance. It doesn't check if it's properly defined in the correct PublicDependencyModuleNames or PrivateDependencyModuleNames list or if it is commented out.\nPublicDependencyModuleNames.AddRange(new string[]\n{\n  \"Core\",\n  \"CoreUObject\",\n  \"Engine\",\n  \"InputCore\",\n  \n  // \"GameplayAbilities\",\n  \"GameplayTags\",\n  \"GameplayTasks\",\n  \n  \"BlueprintAttributes\"\n});\nNow, the Wizard window shouldn't have any warning or errors and should look like the following:","attribute-wizard-fields#Attribute Wizard Fields":"","class-type#Class Type":"The Class Type option is the first field, and lets you choose whether you want the C++ header to be generated within a Public/ folder, or alongside the .cpp file in the Private/ folder.If you wish other modules to be able to access the C++ AttributeSet, then using Public is recommended.The nice thing about the preview window is that it will dynamically update whenever any relevant field is changed.In this case, a Public class type will generate the MODULENAME_API dll export macro, while if choosing Private it is not needed anymore and won't be included with the header class definition.\nIf we switch the preview to Source, the other part that changes depending on Class Type is the include path for the header, if we have a relative sub path.","parent-class#Parent Class":"The second field is the Parent Class, this lets you choose a specific Attribute Set base class to inherit from.\nThe combo box should list all the AttributeSet subclass available in the project, and the default value is simply UAttributeSet which is the recommended class to use.You can choose GBAAttributeSetBlueprintBase if you wish to maintain the ability to use the BP exposed events and methods in Blueprints (while having the actual FGameplayAttribute properties defined in C++).","name#Name":"The next field is Name text box, that lets you customize the C++ classname and resulting header / source file names. It is by default the same as the .uasset name of the original Blueprint AttributeSet we opened the wizard from.","target-module#Target Module":"Next to the Name textbox, the Target Module combo box lets you pick a different module for the C++ generated class. By default, it is set to the Game module and is the first entry in the combo box.\nIt'll change the Header and Source file paths on selection (and is directly related to Required Module Dependencies).","relative-path#Relative Path":"Relative Path text field lets you change the relative path beneath the target module source path.\nYou can click the little  icon next to the text box to open the OS Directory Dialog and pick a different location (must be within the target module source path).","header--source-files#Header / Source files":"Those two read-only fields are changed whenever Name, Target Module, or Relative Path are changed.","generate-from-blueprint#Generate From Blueprint":"The Generate From Blueprint combo box field lets you pick a different Blueprint AttributeSet. It is by default the original Blueprint AttributeSet asset for which the Wizard was first opened.\nDon't forget to change the Name field appropriately if you change this value.The preview window will be updated accordingly upon choosing a new Blueprint here.","preview-header--source#Preview: Header / Source":"This group of buttons lets you change the preview window just below, to either preview the Header or Source file that is going to be generated when the Create Class button is clicked.","settings-#Settings ":"The  Settings button can be used to adjust a variety of config options related to the preview window. You can change syntax highlighting colors here, or the font size.Those settings are the same as Blueprint Attributes > Scaffold Preview Settings and can be accessed via the Editor Preferences window as well.","create-class#Create Class":"Upon clicking the \"Create Class\" button.","credits#Credits":"The slate widgets responsible for source and header preview is directly inspired and based off the Blueprint Header View feature and module that was introduced in 5.1.The very first time I've seen this feature in action in the editor kind of surprised me (in a very nice way), and I immediately thought about how it could be to used to have this kind of source preview in a C++ Class generator.So all the credits goes towards Epic for introducing such a nice feature, whose BlueprintHeaderView plugin and module is the original instigator and author of technical details for implementing something like this."}},"/docs/blueprint-attributes-editor":{"title":"Blueprint Attributes Editor","data":{"":"Upon first opening, the Blueprint Editor will look like this.\nA few additional buttons can be found in the toolbar, next to the PIE and Debugging controls.We will go over each of these buttons shortly.","creating-a-new-attribute#Creating a new Attribute":"","add-attribute-button#Add Attribute Button":"But first let's click on the \"Add Attribute\" button.This combo button brings up a new panel with a form and a few inputs to help with the creation of new Gameplay Attribute properties.\nThe type can be either FGameplayAttributeData or FGBAGameplayClampedAttributeData (FGameplayAttributeData with built-in clamping features)\nThe Replication checkbox can be used if the Attribute needs to be replicated, and will generate the appropriate Rep_Notify function and implementation.\nIt's a quicker and less error-prone way of creating a new Gameplay Attribute variable, by enforcing proper types and saving a few clicks / manual steps.You should now have a newly created Gameplay Attribute variable, with type FGameplayAttributeData.Along with an \"OnRep_Health\" function (the rep notify) if you checked the Replication checkbox.","attribute-details#Attribute Details":"With the Health variable selected, the Detail panel should look like this.The important part that is customized by the plugin is the Default Value panel, where you can see the Base and Current value of the Attribute, and change its default value directly from within the Blueprint Editor (courtesy of one of our Details customization class, FGBAGameplayAttributeDataDetails).","rep-notify#Rep Notify":"if you checked the Replication checbox, a rep notify function should be implemented for you, with the required call to HandleRepNotifyForGameplayAttribute().The main role of HandleRepNotifyForGameplayAttribute() is to handle attributes that will be predictively modified by clients, something that is usually done with GAMEPLAYATTRIBUTE_REPNOTIFY helper macro in C++.","class-defaults#Class Defaults":"Now that we have at least one variable created, we can take a look at the Details panel for the Class Defaults (by clicking on this button in the toolbar)It is adding a new \"Add Attribute\" button (same function as the one in the toolbar) and listing each and every BP variables. The Gameplay Attribute Data properties are then displayed like here, providing you a simple way to see and tweak all your Attributes at once and their default values.Here is an example with an Attribute Set and more Gameplay Attributes.","details-settings#Details Settings":"You can customize that part of the Editor with few Details Customization option in the Project Settings.Open up the Project Settings, then scroll down to the bottom of the sidebar. You should see a \"Blueprint Attributes\" section where all the configurable settings for the Plugin can be found.\nUse Compact ViewIf you turn on Compact View mode in the Project Settings, Details for Gameplay Attributes Data properties will be simplified and use a simplified display.For both class defaults variables and when viewing / editing a single Attribute Data property, making the edition of BaseValue possible in the header of the row.Only for simple Gameplay Attribute Data properties, clamped properties still display using the full extended version (like the Endurance Attribute above, we'll go over Gameplay Clamped Attribute properties in their own section)Header Format TextThe other relevant setting is \"Header Format Text\".Customize how the header row is displayed and what should be included. This is a FText::Format format string, with two floats being passed in as an argument (BaseValue and CurrentValue). Both float values are converted to String with \"%.2f\" to reduce precision to only two decimals (Default Value: \"Base: {0}, Current: {1}\")You could even get fancy and use utf8 emojis in there 😉"}},"/docs/create-blueprint-attribute-set":{"title":"Create a Blueprint Attribute Set","data":{"":"First thing first, we need to create the Blueprint for our Attribute Set. To do so, right click in the Content Browser and click on:Gameplay > Gameplay Blueprint Attributes > Gameplay Blueprint Attribute SetThe prefix used here for Blueprint Attribute Sets will be \"GBA_\", standing for Gameplay Blueprint Attributes.We're going to implement a simple AttributeSet to hold a Health variable: GBA_Health_Set\nIt is highly recommended to always use the Context Menu asset action to create new Blueprint Attribute Sets.\nDoing so will ensure the Blueprint is using a specific UBlueprint (UGBAAttributeSetBlueprint) and a customized BlueprintEditor (FGBABlueprintEditor). We will go over briefly each of its features."}},"/docs/exec-calc":{"title":"Gameplay Effect Execution Calculation","data":{"":"This page is a work in progress","gameplay-effect-execution-calculation#Gameplay Effect Execution Calculation":"Related https://github.com/tranek/GASDocumentation#concepts-ge-ec","requirements#Requirements":"Blueprint parent class needs to be UGameplayEffectExecutionCalculation.Override the functions Execute, the equivalent of the Execute_Implementation. when done in C++.\nMake sure to edit the Relevant Attributes to Capture in Class Defaults, with all the Attributes your calculation will need. You can tweak this array as you go depending on the implementation of your execution.","calculation#Calculation":"Blueprint Attributes defines a few Blueprint statics (eg. methods from within a Blueprint Library globally accessible) to help in the implementation, namely:\nGetOwningSpec()\nGetEffectContext()\nGetSourceTags()\nGetTargetTags()\nAttemptCalculateCapturedAttributeMagnitude()\nFor this to work correctly, the Attribute needs to be added to the Relevant Attributes to Capture array.\n()\nFor this to work correctly, the Attribute needs to be added to the Relevant Attributes to Capture array.\nAddOutputModifier()\nThey all take as an input parameter the original FGameplayEffectCustomExecutionParameters structure that is passed down to the Execute method as an input parameter. Since it's a method (and not an event in the main event graph), feel free to leverage the fact it is a local variable to help in reducing wires throughout the event graph for your method.Simply type Get Execution Params anywhere in the method event graph to access it.\nBy default, UGameplayEffectExecutionCalculation is Blueprintable but doesn't define any Blueprint exposed methods or helpers to actually base the entire calculation logic purely in Blueprint. Those few custom methods were designed to help implementing Exec Calc classes in Blueprints.They can work off Attributes defined in either C++ or within Blueprint AttributeSets (GBA prefixed in this sample).","example#Example":"Capture Source / Target tags and relevant Attributes (don't forget to add them to the Relevant Attributes to Capture prop in class defaults)\nSourceTags, TargetTags, BaseDamage, AttackPower, Armor are all local variables.\nDo the calculation (based on info gathered in step 1.)\nAdd any number of output modifiers and return the Execution Output.\nThese output modifiers don't necessarily need to be captured as Relevant Attributes.Make sure to return the result Execution Output.If you want to output more than one modifier, you can do so by chaining the calls and passing down the Execution Output of one modifier to the next.The first one will have to Make GameplayEffectCustomExecutionOutput the initial structure."}},"/docs/gameplay-effects":{"title":"Gameplay Effects","data":{"":"Gameplay Effects don't change (much). They still function the same with Blueprint Attributes plugin. This document aims to go through the few subtle differences and settings related to Gameplay Effects details customizations.","gameplay-attribute-dropdown#Gameplay Attribute Dropdown":"The dropdown available in the Modifiers array, or anywhere else a FGameplayAttribute property appear, is strictly identical to the engine default customization.The main difference consists of allowing the display of FGameplayAttribute FProperties defined in the Blueprints, alongside the standard ones defined in C++, within the Attribute picker dropdown.","blueprint-and-c-attributes#Blueprint and C++ Attributes":"All GBA_ prefixed Attribute Sets are Blueprints with FGameplayAttributeData properties.","gain-focus-on-filter-search-box#Gain focus on filter search box":"The other subtle difference is related to gaining focus immediately on the search box upon opening the combo box for the Attribute Picker.\nThis is now a default behavior in 5.3, but this wasn't the case in previous engine versions.\nYou can immediately start typing to filter attributes when the attribute combo box is opened.","filter-attributes#Filter Attributes":"Blueprint Attributes plugin provides the option to setup Attribute Filters in the Project Settings. It will allow you to hide and prevent specific Attributes from showing up in the Gameplay Attribute Picker.Open up the Project Settings, and scroll down the left sidebar all the way down, until you see the \"Blueprint Attributes\" section, just below \"Plugins\".You can then expand the Details Customization > Attributes category to find the Filter Out Attributes in Details View setting.\nThis is a simple list of FStrings, allowing you to define a list of gameplay attributes to ignore in attributes picker widget.Allows you to filter out a list of gameplay attributes from Attribute Sets in Gameplay Effects Blueprint or any Blueprint nodes listing them (such as with GetFloatAttribute() node)It can be useful if your project is never using pre-defined Attributes (such as AbilitySystemComponent.OutgoingDuration / IncomingDuration), or plugins (such as GAS Companion GSCAttributeSet).This is a StartsWith search pattern, meaning any value here should be the beginning of an attribute (or set) we'd like to ignore, for example:\nAbilitySystemComponent\nAbilitySystemComponent.OutgoingDuration\nAbilitySystemComponent.IncomingDuration\nGSCAttributeSet\nGSCAttributeSet.Mana"}},"/docs/mmc":{"title":"Modifier Magnitude Calculation","data":{"":"This page is a work in progress","modifier-magnitude-calculation#Modifier Magnitude Calculation":"Related https://github.com/tranek/GASDocumentation#concepts-ge-mmc","requirements#Requirements":"Blueprint parent class needs to be UGameplayModMagnitudeCalculation.Override the functions CalculateBaseMagnitude, the equivalent of the CalculateBaseMagnitude_Implementation when done in C++.\nMake sure to edit the Relevant Attributes to Capture in Class Defaults, with all the Attributes your calculation will need.","calculation#Calculation":"Start implementing your calculation.The built-in UGameplayModMagnitudeCalculation from the Engine already has a lot of BP exposed helpers. The Blueprint Attributes plugin doesn't need to add more (I'd just have to ensure calculation on BP defined Attributes are still working).This includes:\nGetCapturedAttributeMagnitude()\nFor this to work correctly, the Attribute needs to be added to the Relevant Attributes to Capture array.\nGetSetByCallerMagnitudeByName()\nGetSourceAggregatedTags()\nGetSourceActorTags()\nGetSourceSpecTags()\nGetTargetAggregatedTags()\nGetTargetActorTags()\nGetTargetSpecTags()\n~ https://docs.unrealengine.com/5.3/en-US/API/Plugins/GameplayAbilities/UGameplayModMagnitudeCalculation/","warning-for-engine-prior-to-53#Warning for engine prior to 5.3":"For engine prior to 5.3, you'll need to rely on a workaround for the issue of const methods. This is fixed in 5.3 and not required anymore.\nBy wiring in a pure const method that returns a reference to self for any BP exposed methods of MMC (like GetCapturedAttributeMagnitude)","example#Example":"SourceTags, TargetTags, CapturedWeight, CapturedFatigue, FatigueState, Result are all local variables."}},"/docs/project-setup":{"title":"Project Setup","data":{"":"The few steps explained here are the minimum requirements to get started with this plugin.","enabling-the-plugin#Enabling the plugin":"Make sure to enable the plugin in the Plugins Window.Doing so will also enable \"Gameplay Abilities\" plugin as well (plugin dependency).Once done, you can restart the project.","adding-the-asc-ability-system-component#Adding the ASC (Ability System Component)":"Add the actor component \"Ability System\" to your Character Blueprint, rename it to AbilitySystemComponent for good measure.In the components panel, click the \"Add\" button and search for \"AbilitySystem\".\nRename the component to \"AbilitySystemComponent\" (optional, but it'll keep it consistent as if it was added in C++)\nAdding the ASC to your Actors is usually done in C++ (and before engine 5.0, it was mandatory). For example in Lyra or using GAS Companion, you'd have this component created for you already. For the purpose of these instructions, we simply add the component in Blueprint and you can freely skip this step if this is applicable to you.","register-attribute-sets-with-the-asc#Register Attribute Sets with the ASC":"In the next sections, we are going to create Attribute Sets (in Blueprint!).\nThe prefix used here for Blueprint Attribute Sets will be \"GBA_\", standing for Gameplay Blueprint Attributes. But you are free to choose the prefix for your project and name them as you please.\nYou will eventually have to register the Attribute Sets with the appropriate ASC for these Attributes to appear and have an impact in-game. You can do so with either:\nOnBeginPlay and using the InitStats() method on the ASC (this is engine API)\nYou can also add the Attribute Set type to the ASC's Default Starting Data (in the details panel with ASC selected, again engine API). Keep in mind that for it to work, you need to provide both the Attribute Set type and a DefaultStartingTable DataTable (even if the latter is empty). This is the current engine implementation skipping initialization if the DataTable is not provided.\nDetails panel with Ability System Component selected in the Blueprint Editor\nA third method depends on your usual GAS backend. Be it Lyra / GAS Companion or you own implementation, they each have their own way of providing a list of Attributes to grant (conceptually similar to DefaultStartingData in 2.)\nWith GAS Companion, you can for instance use the Granted Attributes array on the ASC or an Ability Set. In Lyra, you'll likely register Attribute Sets via a PawnData and an AbilitySet DataAsset.\nOr even,  if you use Game Features, via a GameFeature action (in GAS Companion or Lyra) and the Attributes list they both provide."}},"/docs/referencer-handlers":{"title":"Referencer Handlers","data":{"":"There is an Editor Subsystem defined by Blueprint Attributes plugin whose role is to take care of Attribute properties renames in Blueprints. This system is called internally \"Referencer Handlers\"."}},"/docs/resources/content-examples-project":{"title":"Content Examples Project","data":{}},"/docs/save-game":{"title":"Save Game","data":{"saving-and-loading-attributes#Saving and Loading Attributes":"This page is a work in progress\nWhile BlueprintAttributes is not a Save Game framework, and save games is highly project specific, it was important to ensure BP defined GameplayAttributes are still serializable and support for Save Game is possible.","usage-in-blueprint#Usage in Blueprint":"","1-create-a-savegame-bp#1. Create a SaveGame BP":"Create a Blueprint child of USaveGame to store and load variables related to your game. If you already have a SaveGame object, you're good to go and can skip this step.\nCreate a new variable of type Byte.\nMake sure to turn it into an Array.\nYou can add as many properties as you'd like to save, but ensure you create one as an array of \"Byte\" to be able to serialize / deserialize Attribute Sets and their Gameplay Attributes.","2-mark-attributes-to-save-with-savegame-property#2. Mark attributes to save with SaveGame property":"To make a GameplayAttribute suitable for serialization, you can use the SaveGame property to mark individual attributes as \"save gameable\".\nClick the C++ tab below for Attributes defined in native.\nSelect the Gameplay Attribute to opt-in for save game and serialization.In the details panel, click the \"Advanced\" category, and enable the SaveGame flag by turning on the checkbox.\nSimply add the SaveGame UPROPERTY specifier to your attributes.\nUPROPERTY(BlueprintReadOnly, Category = \"Default\", ReplicatedUsing = OnRep_Health, SaveGame)\nFGameplayAttributeData Health = 0.f;\nATTRIBUTE_ACCESSORS(UClamping_Example_HealthSet, Health)","3-on-saving#3. On Saving":"On saving and creating (or loading from slot) a save game object, make sure to call SerializeAbilitySystemComponent from GBA Serialization BlueprintLibrary, passing down the relevant Ability System Component (that holds the AttributeSets to save) and the array of Bytes from save game to store binary data. Make sure to turn on bIsSaveGame parameter to true.\nThe bIsASCImplementingSerialize can be turned on if your AbilitySystemComponent native parent class is overriding Serialize() and handles save game serialization. If it's not or if you attached an AbilitySystemComponent actor component directly in Blueprint, you can leave it turned off and ignore the explanation below.This can be quickly implemented with:\nvoid UMyAbilitySystemComponent::Serialize(FArchive& Ar)\n{\n\tSuper::Serialize(Ar);\n\tif (Ar.IsSaveGame())\n\t{\n\t\tFGBAUtils::SerializeAbilitySystemComponentAttributes(this, Ar);\n\t}\n}\nAll FGBAUtils::SerializeAbilitySystemComponentAttributes is doing is iterating over spawned attribute sets and calling AttributeSet->Serialize(Archive) on each.\nconst TArray<UAttributeSet*>& AttributeSets = GetSpawnedAttributes();\nfor (UAttributeSet* AttributeSet : AttributeSets)\n{\n\tif (AttributeSet)\n\t{\n\t\t// Assuming AttributeSet is implementing serialize and invokes FGBAUtils::SerializeAttributeSet\n\t\tAttributeSet->Serialize(InArchive);\n\t}\n}","4-on-loading#4. On Loading":"Call the same SerializeAbilitySystemComponent() but this time with bIsSaving parameter to false, passing down the relevant Ability System Component (that holds the AttributeSets to restore) and the array of Bytes from save game where binary data was stored.You don't need to manually handle setting the Attribute values, this is done in SerializeAbilitySystemComponent() automatically by reading back the stored value from the Archive (with bIsSaving to false).","summary#Summary":"Here's a basic flow of Save / Load to save the attributes on Ctrl+S, and load them back on Ctrl+L.\nHave a SaveGame object with an Array of Bytes property.\nPass down the binary data to UGBASerializationBlueprintLibrary::SerializeAbilitySystemComponent()\nMake sure bIsSaving is turned on Save, and turned off on Load.","integration-examples#Integration Examples":"","with-easy-multi-save#With Easy Multi Save":"Work in progress section, but briefly:\nGameplay Attributes to save must have the SaveGame flag (as described here)\nThe AbilitySystemComponent to serialize must implement and override the Serialize method, can only be done in native.\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass EMSEXAMPLES_API UEMSAbilitySystemComponent : public UAbilitySystemComponent\n{\n\tGENERATED_BODY()\npublic:\n\tvirtual void Serialize(FArchive& Ar) override;\n};\nvoid UEMSAbilitySystemComponent::Serialize(FArchive& Ar)\n{\n\tSuper::Serialize(Ar);\n\tif (!Ar.IsSaveGame())\n\t{\n\t\treturn;\n\t}\n\tconst TArray<UAttributeSet*>& AttributeSets = GetSpawnedAttributes();\n\tfor (UAttributeSet* AttributeSet : AttributeSets)\n\t{\n\t\tif (!AttributeSet)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tAttributeSet->Serialize(Ar);\n\t}\n}\nThe Owner Actor must have the AbilitySystemComponent as one of its actor components (can be added in Blueprint from the components window)\nThe Owner Actor must return it as components to save in the EMS provided interface \"ComponentsToSave\" implementation."}},"/":{"title":"Index","data":{}},"/docs/attribute-sets/replication":{"title":"Replication","data":{"":"For multiplayer projects, you can replicate your Gameplay Attribute defined in Blueprints similar to how you would replicate any other property, with some requirements to use rep notifies and call a specific function within them.","getlifetimereplicatedprops#GetLifetimeReplicatedProps":"GetLifetimeReplicatedProps() is implemented in UGBAAttributeSetBlueprintBase (Attribute Set Blueprint Base), the UAttributeSet runtime class Blueprint AttributeSet are inheriting from.It's using the same pattern as Actor Replication or Actor Components, which is going through UBlueprintGeneratedClass::GetLifetimeBlueprintReplicationList() to collects all FProperties (Blueprint variables) that are marked for replication.","rep-notififies#Rep Notififies":"Using rep notifies, you can handle attributes that will be predictively modified by clients. In Blueprints, that means using RepNotify for the replication option and calling HandleRepNotifyForGameplayAttributeData() within the corresponding RepNotify function implementation.Make sure you're using RepNotify for the Replication option\n(Blueprint equivalent of C++ GAMEPLAYATTRIBUTE_REPNOTIFY helper macro).Make sure you're calling HandleRepNotifyForGameplayAttributeData() within the Rep Notify function graph\nIf the Attribute Data property is a clamped property of type FGBAGameplayClampedAttributeData, the handler method to call is HandleRepNotifyForGameplayClampedAttributeData().\nThe \"Add Attribute\" button available in the toolbar or in the Class Defaults panel can be used to automate the creation of replicated properties.If the replication checkbox is checked, the created Attribute property will use RepNotify for its replication option, and the corresponding rep notify function will be created for you with the required call to HandleRepNotifyForGameplayAttributeData()","why-its-important#Why it's important":"You'll find that using simply Replicated without a rep notify (or using RepNotify but without calling HandleRepNotifyForGameplayAttributeData() or in C++ the equivalent GAMEPLAYATTRIBUTE_REPNOTIFY helper macro) for the Attribute property will work for most of the Attribute functionnality (eg. Attribute modification via Gameplay Effects replicate properly).But one noticeable issue arise with Gameplay Attribute Changes delegates, that Ability or Async tasks uses internally.\nASC->GetGameplayAttributeValueChangeDelegate(Attribute);\nUAbilityAsync_WaitAttributeChanged and UAbilityTask_WaitAttributeChangeThreshold are two engine examples where it's used.If the Attribute is set to replicate, but doesn't notify the Ability System of the predictive change, you'll find the delegate for attribute changes doesn't fire properly anymore in a networked environment.\nFirst video with correct replication option and rep notify\nSecond video with incorrect replication option (only Replicated), or with a Rep Notify that omits the call to HandleRepNotifyForGameplayAttributeData().\nNotice how the Attribute values still replicates (the Overlay debug widget with AbilitySystem.DebugAttribute) but the Progress Bars of the UMG fell out of sync (UMG that is using internally Wait For Attribute Changed async task).\nThis demonstration setup can be found in the Content Examples project in the 02_Builtin_Clamping map. The UMG responsible for the Attributes progress bars is WB_Clamping_Attribute_Bar.","data-validation#Data Validation":"We went through how important it is in a networked environment to setup the Attributes properly, and how error-prone it could be. That's why it's important to create the Blueprint AttributeSet using the Asset Actions and Factory the plugin provides (using the Content Browser context menu).This will ensure:\nThe parent class is set to the appropriate one (UGBAAttributeSetBlueprintBase, namely for GetLifetimeReplicatedProps() implementation and to gain access to the BP exposed events / functions and helper methods)\nBlueprints are using FGBABlueprintEditor for their asset editor.\nBesides the custom toolbar, the Blueprint Attribute Set Editor has one key role: Data Validation.","validation-rules#Validation Rules":"In this section, we are going to go through each of the Validation rules, related to replicated Attribute properties, the plugin implements via both UGBAAttributeSetBlueprintBase (Attribute Set Blueprint Base) (runtime class to use for Blueprint parent class, child class of UAttributeSet) and FGBABlueprintEditor (The editor class that implements a custom FBlueprintEditor | FAssetEditorToolkit)The rules are as follow:\nAll attribute replicated properties must use RepNotify for their replication option\nChecks all attribute replicated are implementing the corresponding rep notify function\nChecks all rep notify functions for an attribute are using HandleRepNotifyForGameplayAttribute() (and is wired in to the execution pin)\nIt is using the correct FGameplayAttributeData property for its parameter (name of the rep notified and the InAttribute property should match)"}},"/docs":{"title":"Introduction","data":{"":"The \"Gameplay Blueprint Attributes\" plugin, also known as \"Blueprint Attributes\" or GBA for short, is a valuable extension to the Gameplay Ability System (GAS) plugin. It addresses a fundamental limitation of the Unreal Engine, making UAttributeSet fully blueprintable. This enhancement allows for a seamless workflow entirely within the Unreal Engine Editor and Blueprints, simplifying the process of working with Attribute Sets and Gameplay Attributes.","the-problem#The Problem":"Without the Blueprint Attributes plugin, Unreal Engine requires that Attributes and Attribute Sets must be created exclusively in native code, rendering Blueprint creation impossible. This limitation can be restrictive for Game Designers and Blueprint Developers, hindering their ability to iterate swiftly on Attribute design.","solution#Solution":"This plugin seek to enhance the overall experience of creating and managing Attributes and Attribute Sets.Blueprint Attributes is designed as a powerful solution to the inherent limitations of Unreal Engine, specifically when it comes to the creation and management of Attributes and Attribute Sets. We recognize that Unreal Engine's default behavior mandates the creation of these vital components exclusively in native code, preventing Game Designers and Blueprint Developers from fully harnessing the potential of Blueprints during game development with GAS.Empowering Blueprint Development: Blueprint Attributes steps in to empower Blueprint Developers and Game Designers by providing a robust and user-friendly framework for managing Attributes. This means that you no longer need to rely solely on C++ coding to define and manipulate Attributes and Attribute Sets. With Blueprint Attributes, you can seamlessly integrate Attributes into your Blueprint-based workflows, eliminating the need for complex and time-consuming native code implementations.Fostering Rapid Iteration: One of the core objectives of Blueprint Attributes is to foster rapid iteration and experimentation during the game development process. By allowing you to work directly within the Unreal Engine Editor and Blueprints, Blueprint Attributes streamlines your workflow and minimizes the obstacles that traditionally slow down the iteration cycle. You can now make real-time changes to Attributes and Attribute Sets, test them, and iterate as needed without the impediments of native code development.Enhancing Collaboration: Blueprint Attributes not only empowers individual developers but also enhances collaboration within development teams. Game Designers can work closely with Blueprint Developers to fine-tune Attributes, leveraging the intuitive visual scripting capabilities of Blueprints. This fosters better communication and a more iterative and collaborative approach to game design.Preserving Compatibility: While Blueprint Attributes introduces a Blueprint-centric approach to Attribute management, it also maintains compatibility with the existing Gameplay Abilities ecosystem and workflow. This ensures that your project remains aligned with Unreal Engine's best practices while benefiting from the advantages of Blueprint-based Attribute creation.The plugin serves as a bridge between the intuitive visual scripting capabilities of Blueprints and the robust performance of native code. This allows for a seamless transition from prototyping in Blueprints to the optimized efficiency of C++. The Attribute Wizard, a key feature of Blueprint Attributes, streamlines this transition process, providing a clear path to convert Blueprint-defined Attributes into efficient C++ classes.In summary, Blueprint Attributes is your solution to breaking free from the constraints of native code when working with Attributes and Attribute Sets in Unreal Engine. By offering a user-friendly and versatile approach to Attribute management, it empowers developers, accelerates iteration cycles, encourages collaboration, and seamlessly integrates with existing workflows. With Blueprint Attributes, you're not just overcoming a limitation; you're unlocking the full potential of Unreal Engine's Blueprint system for your game development journey.","plugin-features#Plugin Features":"Blueprint Attributes comes equipped with an extensive set of features to enrich the developer experience and maintain compatibility with the existing Gameplay Abilities ecosystem and workflow. These features include:\nRuntime Module: A runtime module provides a base UAttributeSet class for inheritance.\nCustom UBlueprint and FBlueprintEditor: Custom classes that facilitate Blueprint-based Attribute management.\nEditor Modules: Additional modules for streamlined editor integration.\nDetails Customizations: A wide array of classes and Slate widgets to fine-tune attribute details within the Unreal Editor.\nAttribute Wizard: A powerful tool designed to assist in transitioning from Attributes defined in Blueprints to C++ classes. It generates the appropriate C++ class based on the AttributeSet defined in Blueprints and the Attributes it contains. This allows developers to either inherit from the generated class or migrate entirely to native implementations.\nBy providing these features, Blueprint Attributes aims to simplify the workflow and maximize flexibility when working with Attributes in Unreal Engine.","key-features-of-blueprint-attributes-plugin#Key Features of Blueprint Attributes Plugin":"Key Features of Blueprint Attributes Plugin\nQuicker Iterations\nEmpower Game Designers and Blueprint Developers to rapidly iterate on Attribute design.\nDefine Attributes in Blueprint\nCreate Attribute property variables in the Blueprint Editor for immediate use in Gameplay Effects, K2 Nodes (e.g., GetFloatAttribute()), and other locations where a Gameplay Attribute picker is applicable.\nBuilt-in Clamping\nSupport for clamping via Data Table initialization.\nHandling of \"Min Value\" and \"Max Value\" columns.\nCustomizable clamping using a special Gameplay Clamped Attribute Data property (a child of FGameplayAttributeData) with float or Attribute-based clamping.\nCustomized Blueprint Editor\nBlueprint Editor with Data Validation.\nToolbar with quick-access buttons for:\nAdding Gameplay Attribute properties.\nCreation of Data Tables.\nPorting BP Attribute Sets to standard C++ Attribute Sets.\nDetails Customizations to expose Attribute BaseValue to Blueprint and set it directly from the Details panel.\nInteractions with Gameplay Effects\nAttribute Sets can override several functions to control how an Attribute responds when a Gameplay Effect attempts to modify it.\nMost of this API is exposed to Blueprints (e.g., PostGameplayEffectExecute, Pre/PostAttributeChange).\nReplication\nReplication support for Gameplay Attributes defined in Blueprints, suitable for multiplayer projects.\nHandling of LifetimeReplicatedProps.\nIntegration of rep notifies to manage predictively modified attributes by clients (equivalent to the C++ GAMEPLAYATTRIBUTE_REPNOTIFY macro).\nIntegration with K2 Nodes\nK2 Nodes (Blueprint nodes) that use FGameplayAttribute parameters now display a list of Attributes defined in Blueprints in the combo box, similar to Gameplay Attribute properties in Gameplay Effects.\nAttribute Wizard for Blueprint to C++ Transition\nA wizard and Scaffold module facilitate the transition from Blueprint-defined Attributes to C++.\nGenerates proper C++ header and source files (with preview!) based on defined Gameplay Attributes in the BP Attribute Set.\nReferencer Handlers\nDetects Attribute renaming in the Blueprint Editor.\nOffers to replace previous references to the renamed Attribute in Gameplay Effects.\nDisplays a list of modified properties and Blueprint nodes (K2Nodes) in the message log with clickable links for easy navigation to the referencers.\nThese features collectively enhance your workflow, simplify Attribute management, and provide powerful tools for Blueprint-based development within Unreal Engine."}}}